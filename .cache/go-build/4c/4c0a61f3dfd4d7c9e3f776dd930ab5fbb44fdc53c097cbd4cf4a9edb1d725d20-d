// Code generated by cmd/cgo; DO NOT EDIT.

//line /root/go/pkg/mod/github.com/!cosm!wasm/wasmvm@v1.0.0/api/memory.go:1:1
package api

/*
#include "bindings.h"
*/
import _ "unsafe"

import "unsafe"

// makeView creates a view into the given byte slice what allows Rust code to read it.
// The byte slice is managed by Go and will be garbage collected. Use runtime.KeepAlive
// to ensure the byte slice lives long enough.
func makeView(s []byte)  /*line :13:25*/_Ctype_ByteSliceView /*line :13:40*/ {
	if s == nil {
		return  /*line :15:10*/_Ctype_ByteSliceView /*line :15:25*/{is_nil: true, ptr: cu8_ptr(nil), len: cusize(0)}
	}

	// In Go, accessing the 0-th element of an empty array triggers a panic. That is why in the case
	// of an empty `[]byte` we can't get the internal heap pointer to the underlying array as we do
	// below with `&data[0]`. https://play.golang.org/p/xvDY3g9OqUk
	if len(s) == 0 {
		return  /*line :22:10*/_Ctype_ByteSliceView /*line :22:25*/{is_nil: false, ptr: cu8_ptr(nil), len: cusize(0)}
	}

	return  /*line :25:9*/_Ctype_ByteSliceView /*line :25:24*/{
		is_nil: false,
		ptr:    cu8_ptr(unsafe.Pointer(&s[0])),
		len:    cusize(len(s)),
	}
}

// Creates a C.UnmanagedVector, which cannot be done in test files directly
func constructUnmanagedVector(is_none cbool, ptr cu8_ptr, len cusize, cap cusize)  /*line :33:83*/_Ctype_UnmanagedVector /*line :33:100*/ {
	return  /*line :34:9*/_Ctype_UnmanagedVector /*line :34:26*/{
		is_none: is_none,
		ptr:     ptr,
		len:     len,
		cap:     cap,
	}
}

func newUnmanagedVector(data []byte)  /*line :42:38*/_Ctype_UnmanagedVector /*line :42:55*/ {
	if data == nil {
		return ( /*line :44:10*/_Cfunc_new_unmanaged_vector /*line :44:31*/)(cbool(true), cu8_ptr(nil), cusize(0))
	} else if len(data) == 0 {
		// in Go, accessing the 0-th element of an empty array triggers a panic. That is why in the case
		// of an empty `[]byte` we can't get the internal heap pointer to the underlying array as we do
		// below with `&data[0]`.
		// https://play.golang.org/p/xvDY3g9OqUk
		return ( /*line :50:10*/_Cfunc_new_unmanaged_vector /*line :50:31*/)(cbool(false), cu8_ptr(nil), cusize(0))
	} else {
		// This will allocate a proper vector with content and return a description of it
		return ( /*line :53:10*/_Cfunc_new_unmanaged_vector /*line :53:31*/)(cbool(false), cu8_ptr(unsafe.Pointer(&data[0])), cusize(len(data)))
	}
}

func copyAndDestroyUnmanagedVector(v  /*line :57:38*/_Ctype_UnmanagedVector /*line :57:55*/) []byte {
	var out []byte
	if v.is_none {
		out = nil
	} else if v.cap == cusize(0) {
		// There is no allocation we can copy
		out = []byte{}
	} else {
		// C.GoBytes create a copy (https://stackoverflow.com/a/40950744/2013738)
		out = func() []byte{ _cgo0 := /*line :66:19*/unsafe.Pointer(v.ptr); var _cgo1 _Ctype_int = /*line :66:42*/cint(v.len); _cgoCheckPointer(_cgo0, nil); return _Cfunc_GoBytes(_cgo0, _cgo1); }()
	}
	( /*line :68:2*/_Cfunc_destroy_unmanaged_vector /*line :68:27*/)(v)
	return out
}

// copyU8Slice copies the contents of an Option<&[u8]> that was allocated on the Rust side.
// Returns nil if and only if the source is None.
func copyU8Slice(view  /*line :74:23*/_Ctype_U8SliceView /*line :74:36*/) []byte {
	if view.is_none {
		return nil
	}
	if view.len == 0 {
		// In this case, we don't want to look into the ptr
		return []byte{}
	}
	// C.GoBytes create a copy (https://stackoverflow.com/a/40950744/2013738)
	res := func() []byte{ _cgo0 := /*line :83:19*/unsafe.Pointer(view.ptr); var _cgo1 _Ctype_int = /*line :83:45*/cint(view.len); _cgoCheckPointer(_cgo0, nil); return _Cfunc_GoBytes(_cgo0, _cgo1); }()
	return res
}
